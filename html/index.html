<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>core_arena: README for the core_arena library.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">core_arena<span id="projectnumber">&#160;859f7ea</span>
   </div>
   <div id="projectbrief">An arena allocater that uses core memory aside malloc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">README for the core_arena library. </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
Objective</h1>
<p >Make a heap based arena allocation library for the Linux platform, that is suitable for accessing many small items, note of equal size that <em>can</em> release memory back into <code>malloc's</code> pool of free memory if the allocated chunks are less than 128K, otherwise if chunks arena larger than 128K and <code>mmap</code> is implicitly invoked, release memory back to the system pool. Also safeguard against allocating more memory than physically available, and provide a logging system that is run time configurable, and can be used for tuning, that can be opted out of compile time.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Advantages</h1>
<p >The library lets you allocate memory for an arena from blocks of memory, that you can later de allocate collectively.</p>
<ul>
<li>This makes it easier to release memory no longer need by a stage, object or routine in your program when you are done with it, freeing it to the process heap, or the system memory pool, depending on the size of the allocation.</li>
<li>It is especially useful in situations, where several lifespans memory wise, meets.</li>
<li>It may make overall memory management more efficient, minimizing the number of <code>malloc's</code> and especially <code>free's</code> you have to do in your code.</li>
<li>It can help keep the memory as defragmented as possible using bigger blocks of the process heap, than allocating small objects.</li>
<li>There are runtime logging facilities to help you inspect the library's memory consumption, for tuning, and macros/functions for finding the optimal block size, once you are content, you can opt out the logging facility compile time before you ship. (See: logging system.)</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Motivation</h1>
<p >Be able to use and reuse memory safer, still fast, and efficiently, and have the ability to in some situations tune the memory allocations, by watching the logs of our allocations.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Constraints</h1>
<p >We can't <code>realloc</code> dynamic arrays, any arrays you want to use realloc to grow, or shrink, needs to have been <code>calloc'ed</code> by your system library.</p>
<ul>
<li>We don't under any circumstances use more memory than the system report as physically available.</li>
<li>The library isn't thread safe in any respect, and is for single threaded programs.</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Features</h1>
<p >A runtime logging system, you can opt out of compile time by defining <code>-DCORE_ARENA_NO_LOGGING</code>.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Building</h1>
<p >The library is built by a GNU Make make file but you need to do some work up front by setting some environment variables.</p>
<p >You can build the library both as a static library, as a shared library, or as an object file linked directly into your executable.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Memory Constraints</h1>
<p >It is not intended to be a general purpose allocation that relies on over committing memory, We assume that <code>overcommit_memory==0</code>, and that memory which is physically available, is all you can get. This really isn't then arena_allocator to use if you want pages with 1 megabyte of consecutive memory.</p>
<p >Should you need more than a chunk size of 128K, then <code>malloc</code> will allocate that memory for you via <code>mmap</code>, and <code>free</code> will release the memory back into then systems pool. Not as free memory within then heap. This is for flexibility, and that it works for larger chunks than malloc can provide too.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Requirements</h1>
<p >This version is made for the Linux platform and as such, uses Unix system calls for interacting with the kernel in a more or less portable way, avoiding Glibc features where possible, so, it should be easy to port to any other Unix Systems.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Developing environment</h1>
<p >see Tech Notes.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Installation</h1>
<p >Both the include file <b><a class="el" href="a00005.html" title="A general purpose arena strategy that is based on malloc - header file.">core_arena.h</a></b> and the source file <b><a class="el" href="a00008.html" title="A general purpose arena allocation strategy that is based on malloc.">core_arena.c</a></b> should be installed into your project and you should change the path to the include file into something more fitting if you want to store it apart from <b><a class="el" href="a00008.html" title="A general purpose arena allocation strategy that is based on malloc.">core_arena.c</a></b>.</p>
<p >You can then compile it with your project like your would with any other module.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Configuration in core_arena.h:</h1>
<p >The constants <b>MAX_ALIGN</b> and <b>MALLOC_PTR_SIZE</b> might need to be recalibrated if you aren't on a Linux x86-64 system. You may want to change the constant <b>ARENAS_MAX</b> defines the number of arenas you intend to use, this can't be altered run-time.</p>
<p >The <b>MAX_ALIGN</b> constant denotes the alignment that is used to access memory efficiently.</p>
<p >The <b>MALLOC_PTR_SIZE</b> denotes the pointers size <code>malloc()</code> will use for itself in the allocated block.</p>
<p >The <b>ARENAS_MAX</b> is originally configured for two Arenas, (the index of the arenas starts at <code>0</code>).</p>
<ul>
<li>Specify the number of arenas your intend to use in <code><a class="el" href="a00005.html" title="A general purpose arena strategy that is based on malloc - header file.">core_arena.h</a></code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
You need to configure the upper limit of memory.</h2>
<p >I recommend you compile and run the <code>misc/test.c</code> program: <code>gcc -g3 -o memmax misc/test.c</code> and use the largest value that passes for the <code>#define ARENAS_MAX_ALLOC</code> define constant in <a class="el" href="a00005.html" title="A general purpose arena strategy that is based on malloc - header file.">src/core_arena.h</a>.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Configuring logging.</h2>
<p >We support logging, so you can deduce the memory usage, the logging is only intended for testing, and not to be left on in production code.</p>
<p >The <b>ARENAS_LOG_LEVEL</b> can be defined to <b>NONE</b>, <b>CHUNKS</b>, and <b>EVERYTHING</b>. <b>NONE</b> means there will be no logging, if <b>CHUNKS</b> is specified, then the number of chunks allocated during the lifetime of the arena will be reported. If you use an arena, later destroy it, only to create it a second time, then it is the number from the second usage that is reported. If <b>EVERYTHING</b> is specified, then the total bytes allocated from the chunks are reported too.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Usage Overview</h1>
<h2><a class="anchor" id="autotoc_md14"></a>
Configuring the arena.</h2>
<ul>
<li>Include <code><a class="el" href="a00005.html" title="A general purpose arena strategy that is based on malloc - header file.">core_arena.h</a></code> in any source file you intend to use arena allocation from.</li>
<li>You must call <code>arena_create(n,chunk_sz)</code> before using the arena.</li>
</ul>
<h3><a class="anchor" id="autotoc_md15"></a>
Parameter  explanation:</h3>
<p ><code>n</code> is the number of the arena you configure, with which you will reference the arena when using the other calls.</p>
<p >The chunk_sz you specify is the size of memory that will be handled out during individual <code>arena_alloc/arena_calloc</code> calls. Every arena needs a struct for book keeping,and malloc needs some bytes for book-keeping too. The necessary bytes for book-keeping are subtracted from the specified chunk_sz. I recommend a chunk_sz of a multiple/part of <b>4096</b> (the page size on a Linux platform).</p>
<p ><b>2048</b>, <b>1024</b>, <b>512</b>, <b>256</b>, <b>128</b>, are examples of good fractions of <b>4096</b>. <b>3072</b>, <b>1536</b>, <b>384</b>, and so on, are also good numbers when you known the total number of bytes you need and want to cap the bufsize.</p>
<p >If you are on a different platform than Linux, you should determine what the page size is on your system and use that number of bytes as a vantage point for specifying the chunk size.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Getting memory from the arena into your program.</h2>
<p >You allocate memory for an object in memory with: <code>void *arena_alloc</code>, and memory for a zeroed out array with: <code>void *arena_calloc</code>.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Ending/deallocating an arena.</h2>
<p >When the collective lifetime for the objects of the arena is over you can delete them with <code>arena_dealloc</code> and retain the memory for reuse with the same arena in another lifetime, or your can call <code>arena_destroy</code>, and return the memory back to the operating system.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Beware.</h2>
<p >No calls like <code>free</code> or <code>realloc</code> from <code>stdlib.h</code> will work on pointers to memory returned by the <code>arena_*</code> functions, but most likely generate a segment violation (<code>SIG_SEGV</code>) error.</p>
<p >Even if the logging arrays are defined as <code>long long</code> I recommend you turn logging off in production code, because at some time, there will be either an overflow or wraparound, rendering the numbers useless anyway. The logging report is bypassed if you exit your program with <code>_Exit</code> or a <code>TERM</code> signal, as the report_usage is installed by <code>atexit()</code>.</p>
<hr  />
<p> Last updated:24-01-30 01:03 </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 26 2024 17:02:45 for core_arena by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
